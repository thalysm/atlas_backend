from typing import List, Optional
from datetime import datetime
from ...domain.entities.competition_group import CompetitionGroupEntity, GroupMember
from ...infrastructure.repositories.competition_group_repository import (
    CompetitionGroupRepository,
)
from ...infrastructure.repositories.user_repository import UserRepository
from ...infrastructure.repositories.workout_session_repository import (
    WorkoutSessionRepository,
)


class CompetitionGroupUseCases:
    def __init__(
        self,
        group_repository: CompetitionGroupRepository,
        user_repository: UserRepository,
        session_repository: WorkoutSessionRepository,
    ):
        self.group_repository = group_repository
        self.user_repository = user_repository
        self.session_repository = session_repository

    async def create_group(
        self, owner_id: str, name: str, description: Optional[str]
    ) -> dict:
        """Create a new competition group"""
        # Get owner info
        owner = await self.user_repository.find_by_id(owner_id)
        if not owner:
            raise ValueError("User not found")

        # Create group with owner as first member
        group = CompetitionGroupEntity(
            name=name,
            description=description,
            owner_id=owner_id,
            members=[
                GroupMember(user_id=owner_id, username=owner.username, workout_count=0)
            ],
            invite_code="",  # Will be generated by repository
        )

        group_id = await self.group_repository.create(group)
        created_group = await self.group_repository.find_by_id(group_id)

        return {
            "id": group_id,
            "invite_code": created_group.invite_code if created_group else "",
        }

    async def join_group(self, user_id: str, invite_code: str) -> bool:
        """Join a group using invite code"""
        group = await self.group_repository.find_by_invite_code(invite_code)
        if not group:
            raise ValueError("Invalid invite code")

        # Check if already a member
        if any(m.user_id == user_id for m in group.members):
            raise ValueError("Already a member of this group")

        # Get user info
        user = await self.user_repository.find_by_id(user_id)
        if not user:
            raise ValueError("User not found")

        # Add member
        group.members.append(
            GroupMember(user_id=user_id, username=user.username, workout_count=0)
        )

        return await self.group_repository.update(str(group.id), group)

    async def get_user_groups(self, user_id: str) -> List[dict]:
        """Get all groups for a user"""
        groups = await self.group_repository.find_by_user(user_id)
        return [
            {
                "id": str(g.id),
                "name": g.name,
                "description": g.description,
                "owner_id": g.owner_id,
                "member_count": len(g.members),
                "invite_code": g.invite_code,
                "created_at": g.created_at.isoformat(),
            }
            for g in groups
        ]

    async def get_group_details(self, group_id: str, user_id: str) -> Optional[dict]:
        """Get group details with leaderboard"""
        group = await self.group_repository.find_by_id(group_id)
        if not group:
            return None

        # Check if user is a member
        if not any(m.user_id == user_id for m in group.members):
            raise ValueError("Not a member of this group")

        # Update workout counts for all members
        for member in group.members:
            sessions = await self.session_repository.find_by_user(member.user_id, limit=1000)
            member.workout_count = len([s for s in sessions if s.is_completed])

        # Sort members by workout count
        sorted_members = sorted(
            group.members, key=lambda m: m.workout_count, reverse=True
        )

        return {
            "id": str(group.id),
            "name": group.name,
            "description": group.description,
            "owner_id": group.owner_id,
            "invite_code": group.invite_code,
            "members": [
                {
                    "user_id": m.user_id,
                    "username": m.username,
                    "workout_count": m.workout_count,
                    "joined_at": m.joined_at.isoformat(),
                }
                for m in sorted_members
            ],
            "created_at": group.created_at.isoformat(),
        }

    async def leave_group(self, group_id: str, user_id: str) -> bool:
        """Leave a group"""
        group = await self.group_repository.find_by_id(group_id)
        if not group:
            raise ValueError("Group not found")

        # Can't leave if you're the owner
        if group.owner_id == user_id:
            raise ValueError("Owner cannot leave the group. Delete it instead.")

        # Remove member
        group.members = [m for m in group.members if m.user_id != user_id]

        return await self.group_repository.update(group_id, group)

    async def delete_group(self, group_id: str, user_id: str) -> bool:
        """Delete a group (owner only)"""
        group = await self.group_repository.find_by_id(group_id)
        if not group:
            raise ValueError("Group not found")

        if group.owner_id != user_id:
            raise ValueError("Only the owner can delete the group")

        return await self.group_repository.delete(group_id)
